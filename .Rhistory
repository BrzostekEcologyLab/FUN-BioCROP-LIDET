pool_column_names<-c("uFastC", "uSlowC", "uNecroC",
"pFastC", "pSlowC", "pNecroC",
"livingMicrobeC",
"uFastN", "uSlowN", "uNecroN",
"pFastN", "pSlowN", "pNecroN",
"inorganicN",
"CO2",
"livingMicrobeN")
ncolnames<-length(pool_column_names)
bulk<-data.frame(matrix(0,ncol = ncolnames,nrow = nsites))
names(bulk)<-pool_column_names
# The structure is the same for all layers:
# bulk_till, bulk, rhizo_till, rhizo, litter
bulk_till <- bulk
bulk<-bulk
rhizo_till <- bulk
rhizo<-bulk
litter<-bulk
##Set up lists to hold CORPSE model outputs
# bulk, rhizosphere, and litter layers (as they change over time)
bulk_till_final_list <- list()
bulk_final_list<-list()
rhizo_till_final_list <- list()
rhizo_final_list<-list()
litter_final_list<-list()
## CORPSE assumes that inorganic N is the same across layers
shared_inorganicN<-numeric(nsites)
##Initial Values for all layers (all units are in kg/m-2)
bulk_till[1:nsites,1:ncolnames]<-bulk_till_int[1:nsites,1:ncolnames]
bulk_till$livingMicrobeN<-bulk_till$livingMicrobeC/params$CN_Microbe
bulk[1:nsites,1:ncolnames]<-bulk_int[1:nsites,1:ncolnames]
bulk$livingMicrobeN<-bulk$livingMicrobeC/params$CN_Microbe
rhizo_till[1:nsites,1:ncolnames]<-rhizo_till_int[1:nsites,1:ncolnames]
rhizo_till$livingMicrobeN<-rhizo_till$livingMicrobeC/params$CN_Microbe
rhizo[1:nsites,1:ncolnames]<-rhizo_int[1:nsites,1:ncolnames]
rhizo$livingMicrobeN<-rhizo$livingMicrobeC/params$CN_Microbe
litter[1:nsites,1:ncolnames]<-litter_int[1:nsites,1:ncolnames]
litter$livingMicrobeN<-litter$livingMicrobeC/params_litter$CN_Microbe
##Initializing shared inorganic N pool
shared_inorganicN<-bulk$inorganicN
k<-1:FUNstep
##First calculate amount of  root production and N needed - how much N needed for the timestep
# root N demand - daily N used to produce new belowground biomass
rootNdemand <- matrix(0,nrow=timestep, ncol = nsites)
for (i in 2:length(rootNdemand)) {
rootNdemand[i] <- (input$bglivnj[i] + input$bglivnm[i]) -
(input$bglivnj[i-1] + input$bglivnm[i-1])
}
rootNdemand[rootNdemand < 0] <- 0
rootNdemand[,2] <- rootNdemand[,1]
# leafNdemand- daily N used to produce new aboveground biomass
leafNdemand <- matrix(0,nrow=timestep, ncol = nsites)
for (i in 2:length(leafNdemand)) {
leafNdemand[i] <- (input$aglivn[i]) - (input$aglivn[i-1])
}
leafNdemand[leafNdemand < 0] <- 0
leafNdemand[,2] <- leafNdemand[,1]
##Calculate NPP
NPP<-daily_NPP
##Calculate total N demand
totalNdemand<-rootNdemand+leafNdemand
##Calculate plantCN
plantCN<-NPP/totalNdemand
plantCN[is.nan(plantCN)] = 0
##Replenish N stores during senescence
storageNdemand<-matrix(0,nrow=length(NPP),ncol=nsites)
storageNdemand <- vector()
for (i in 1:length(input$yr)){
if (input$last[i] == 1 && input$harv[i] == 0){
storageNdemand[i] <- input$aglivn[i-1] * 0.7
} else storageNdemand[i] <- 0
}
##Calculate leaf N available for retranslocation and the amount of C in litter
## Litter production values also used in CORPSE model for intial litter inputs
## If you have a harvest, remove, else retranslocatable n is n pool on last growth day
leafN <- matrix(0,nrow = length(input$aglivc), ncol = 4)
leafN[,1] <- input$last
leafN[,2] <- input$harv
leafN[,3] <- input$aglivn
for (i in 1:length(leafN[,1])){
if (leafN[i,2] == 1){
leafN[i,4] <- leafN[i-1,3] * (1 - input$harvremov[i])  # need a nonzero value
}  else if (leafN[i,1] == 1){
leafN[i,4] <- leafN[i-1,3]
}
}
# calculate litter production if there is harvest
litter_production_c<-vector()
litter_production_n<-vector()
litter_production_c <- agrd_turnover_c
litter_production_n <- agrd_turnover_n
for (i in 1:length(input[,1])) {
if (input$harv[i] == 1){
litter_production_c[i] <- litter_production_c[i] * (1 - input$harvremov[i])
litter_production_n[i] <- litter_production_n[i] * (1 - input$harvremov[i])
}
}
# Code for perennials (used in Energy Farm runs due to harvest timing): Feedstock Harvests occur early in the year to harvest the previous year's plants, so need to reduce all agrd_turnover_c by harvest % otherwise all the aboveground biomass goes into the litter pool
# litter_production_c <- agrd_turnover_c*0.15
# litter_production_n <- agrd_turnover_n*0.15
##Initialize the N and C storage pools. The N is used to grow leaves in Spring.
##Also determine demand in the Fall and C is used for retranslocation
CORPSEstorageN<-vector()
storageC<-vector()
CORPSEstorageN<-storageNdemand
leafCN_frame <- input[,c("yr", "doy", "aglivc", "aglivn", "last")]
for (i in 1:length(leafCN_frame[,"aglivc"])){
if (leafCN_frame[i,"last"] == 1 & leafCN_frame[i, "aglivc"] == 0){
leafCN_frame[i,"aglivc"] <- leafCN_frame[i-1,"aglivc"]
leafCN_frame[i,"aglivn"] <- leafCN_frame[i-1,"aglivn"]
}
}
leafCN <- leafCN_frame$aglivc/leafCN_frame$aglivn
storageC<-storageNdemand * leafCN #assuming that the storage pool of C is equal to the leaf litter C pool
### Create empty matrices for FUN model outputs
Npassive<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg N/m2/timestep) amount of N taken up through passive uptake
free<-matrix(NA,nrow=timestep,ncol=nsites)
storageNmob<-matrix(NA,nrow=timestep,ncol=nsites)
FUNstorageN<-matrix(NA,nrow=timestep+1,ncol=nsites)
FUNstorageN[,1]<-c(0,CORPSEstorageN)
FUNstorageN[,2]<-c(0,CORPSEstorageN)
cost_active<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg N/m2/timestep) cost of active N uptake
cost_fix<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg C/m2/timestep) cost of N fixation
cost_resorb<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg C/m2/timestep) cost of resorption of leaf N
cost_non_myco<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg C/m2/timestep) cost of non-mycorrhizal active N uptake
cost_acq<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg C/m2/timestep) minimum of cost 1) fixation, 2) active, 3) resorb
rec_cost_acq<-matrix(NA,nrow=timestep,ncol=nsites)
Cgrowth<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg C/m2/timestep) C available for NPP and growth
Cgrowth<-NPP  ##First column Cgrowth=NPPmyco
Cacq<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg C/m2/timestep) C expended on N uptake
Nacq<-matrix(NA,nrow=timestep,ncol=nsites) ##(kg N/m2/timestep) Total N taken up
Cavailable<-matrix(NA,nrow=timestep,ncol=nsites)
Cavailable<-NPP ##C available to expend to growth or N uptake
rsoilN<-matrix(NA,nrow=timestep,ncol=nsites) ##soilN remaining after passive uptake
Ndeficit<-matrix(NA,nrow=timestep,ncol=nsites) ##N uptake needed to meet N demand
total_Nacq<-matrix(0,nrow=timestep,ncol=nsites)
total_Cgrowth<-matrix(0,nrow=timestep,ncol=nsites)
total_Nacq_active<-matrix(0,nrow=timestep,ncol=nsites)
total_Nacq_resorb<-matrix(0,nrow=timestep,ncol=nsites)
total_Nacq_fix<-matrix(0,nrow=timestep,ncol=nsites)
total_Nacq_non_myco<-matrix(0,nrow=timestep,ncol=nsites)
total_Nacq_storage<-matrix(0,nrow=timestep,ncol=nsites)
litter_productionN<-matrix(NA,nrow=timestep,ncol=nsites)
litter_productionCN<-matrix(NA,nrow=timestep,ncol=nsites)
rhizoC_flux<-matrix(0,nrow=timestep,ncol=nsites)
fungal_prod<-matrix(0,nrow=timestep,ncol=nsites)
Ndemand_plus_storage<-matrix(NA,nrow=timestep,ncol=nsites)
NPP_plus_storage<-matrix(NA,nrow=timestep,ncol=nsites)
resorbper<-matrix(NA,nrow=1,ncol=nsites)
cost_storage<-matrix(2.0e-3,nrow=timestep,ncol=nsites)
FUN_shared_inorganicN<-matrix(NA,nrow=timestep,ncol=nsites)
total_soil_N_uptake<-matrix(NA,nrow=timestep,ncol=nsites)
N_uptakescaler<-matrix(NA,nrow=timestep,ncol=nsites)
Nacq_scaler<-matrix(NA,nrow=timestep,ncol=nsites)
##model code
##loop needs to happen for nyears for all sites
for (i in 1:timestep) {
##Start CORPSE model main loop
#Parse step into DOY
##this takes the timestep and makes it into DOY
k<-((i-1)%%365)+1
##Get Temperature and theta (soil moisture) values for this time point
T_step<-soilT[k]+273.15
porosity<-0.5
theta_step<-soilVWC[k,1]/porosity
##Running the CORPSE function
bulk_till$inorganicN <- shared_inorganicN
results_bulk_till<-CORPSE(bulk_till,T_step,theta_step,params,claymod,Litter=FALSE)# units of kg change per year
shared_inorganicN <- shared_inorganicN+CORPSEstep*results_bulk_till$inorganicN
bulk$inorganicN <- shared_inorganicN
results_bulk<-CORPSE(bulk,T_step,theta_step,params,claymod,Litter=FALSE)# units of kg change per year
shared_inorganicN <- shared_inorganicN+CORPSEstep*results_bulk$inorganicN
rhizo_till$inorganicN<-shared_inorganicN
results_rhizo_till<-CORPSE(rhizo_till,T_step,theta_step,params,claymod,Litter=FALSE)# units of kg change per year
shared_inorganicN <- shared_inorganicN+CORPSEstep*results_rhizo_till$inorganicN
rhizo$inorganicN<-shared_inorganicN
results_rhizo<-CORPSE(rhizo,T_step,theta_step,params,claymod,Litter=FALSE)# units of kg change per year
shared_inorganicN <- shared_inorganicN+CORPSEstep*results_rhizo$inorganicN
litter$inorganicN<-shared_inorganicN
results_litter<-CORPSE(litter,T_step,theta_step,params_litter,claymod,Litter=TRUE)# units of kg change per year
shared_inorganicN <- shared_inorganicN+CORPSEstep*results_litter$inorganicN
##Update shared inorganic N pool for each layer to take into account inputs (inorg_Ndep) and outputs for inorganic N removal (from plant roots, leaching, etc)
##Record mineralization and immobilization from rates of N pools by timestep
#Add and subtract all changes from shared inorganic N pool
shared_inorganicN <- shared_inorganicN + CORPSEstep *(inorg_Ndep - params$iN_loss_rate*shared_inorganicN)
##model will stop if shared inorganic N < 0
if(min(shared_inorganicN)<0) {crash('Inorganic N < 0')}
##Update the pools in SOM by add derivs*dt (length of time step) to each SOM pool.
##This simply converts the units from mass per year to mass per the selected time step
bulk_till<-bulk_till + results_bulk_till*CORPSEstep
bulk_till$inorganicN<-shared_inorganicN
if(min(bulk_till)<0) {crash('Value is bulk_till < 0')}
bulk<-bulk + results_bulk*CORPSEstep
bulk$inorganicN<-shared_inorganicN
if(min(bulk)<0) {crash('Value is bulk < 0')}
rhizo_till <- rhizo_till + results_rhizo_till*CORPSEstep
rhizo_till$inorganicN<-shared_inorganicN
if(min(rhizo_till<0)) {crash('Value is rhizo_till < 0')}
rhizo <- rhizo + results_rhizo*CORPSEstep
rhizo$inorganicN<-shared_inorganicN
if(min(rhizo<0)) {crash('Value is rhizo < 0')}
litter<-litter + results_litter*CORPSEstep
litter$inorganicN<-shared_inorganicN
if(min(litter<0)) {crash('Value is litter < 0')}
# print counter in R console
if (input$doy[i]==1) print(paste("day", input$doy[i], "of year", input$nyr[i], "of", max(input$nyr), "total years", sep = " "))
# Keep track of latest data
bulk_till_final_list[[i]]<- bulk_till
bulk_final_list[[i]]<-bulk
rhizo_till_final_list[[i]]<- rhizo_till
rhizo_final_list[[i]]<-rhizo
litter_final_list[[i]]<-litter
# rhizo_frac needs to be between 0 and 1
rhizo_frac <- input$rhizo_frac[i]
## CORPSE calculates cumulative CO2 release. This code keeps track of CO2 from each soil pool so that it is maintained when the soils are mixed.  Further down the code the CO2 is reassigned to its individual layers.
CO2_bulk_till<-bulk_till$CO2
CO2_bulk<-bulk$CO2
CO2_rhizo_till<-rhizo_till$CO2
CO2_rhizo<-rhizo$CO2
CO2_litter<-litter$CO2
## Mix bulk soil and rhizo soil together during growing season using froot_turnover_fraction
froot_turnover_fraction <- 1/365
soilMix_bulk_till<-froot_turnover_fraction*bulk_till
soilMix_bulk<-froot_turnover_fraction*bulk
soilMix_rhizo_till<-froot_turnover_fraction*rhizo_till
soilMix_rhizo<-froot_turnover_fraction*rhizo
soilMix <- soilMix_bulk + soilMix_rhizo
soilMix_till <- soilMix_bulk_till + soilMix_rhizo_till
bulk_till<-bulk_till-soilMix_bulk_till
rhizo_till<-rhizo_till-soilMix_rhizo_till
bulk_till<-bulk_till+(soilMix_till*(1.0-rhizo_frac))
rhizo_till<-rhizo_till+(soilMix_till*(rhizo_frac))
bulk<-bulk-soilMix_bulk
rhizo<-rhizo-soilMix_rhizo
bulk<-bulk+(soilMix*(1.0-rhizo_frac))
rhizo<-rhizo+(soilMix*(rhizo_frac))
##Add leaf litter inputs to litter layer
# fastfrac changes with crop type, and by leaf/root litter
leaf_litter_fastfrac <- input$leaf_litter_fastfrac[i]
litter$uFastC<-litter$uFastC+(litter_production_c[i]*leaf_litter_fastfrac)
litter$uSlowC<-litter$uSlowC+(litter_production_c[i]*(1-leaf_litter_fastfrac))
litter$uFastN<-litter$uFastN+((litter_production_n[i]*leaf_litter_fastfrac))
litter$uSlowN<-litter$uSlowN+((litter_production_n[i]*(1-leaf_litter_fastfrac)))
##Add root litter inputs to the rhizosphere and bulk soil layers
root_litter_fastfrac <- input$root_litter_fastfrac[i]
rhizo_till$uFastC<-rhizo_till$uFastC+(froot_turnover_c[i]*pct_soil_tilled*root_litter_fastfrac*rhizo_frac)
rhizo_till$uSlowC<-rhizo_till$uSlowC+(froot_turnover_c[i]*pct_soil_tilled*(1-root_litter_fastfrac)*rhizo_frac)
rhizo_till$uFastN<-rhizo_till$uFastN+(froot_turnover_n[i]*pct_soil_tilled*root_litter_fastfrac*rhizo_frac)
rhizo_till$uSlowN<-rhizo_till$uSlowN+(froot_turnover_n[i]*pct_soil_tilled*(1-root_litter_fastfrac)*rhizo_frac)
rhizo$uFastC<-rhizo$uFastC+(froot_turnover_c[i]*(1-pct_soil_tilled)*root_litter_fastfrac*rhizo_frac)
rhizo$uSlowC<-rhizo$uSlowC+(froot_turnover_c[i]*(1-pct_soil_tilled)*(1-root_litter_fastfrac)*rhizo_frac)
rhizo$uFastN<-rhizo$uFastN+(froot_turnover_n[i]*(1-pct_soil_tilled)*root_litter_fastfrac*rhizo_frac)
rhizo$uSlowN<-rhizo$uSlowN+(froot_turnover_n[i]*(1-pct_soil_tilled)*(1-root_litter_fastfrac)*rhizo_frac)
bulk_till$uFastC<-bulk_till$uFastC+(froot_turnover_c[i]*pct_soil_tilled*root_litter_fastfrac*(1-rhizo_frac))
bulk_till$uSlowC<-bulk_till$uSlowC+(froot_turnover_c[i]*pct_soil_tilled*(1-root_litter_fastfrac)*(1-rhizo_frac))
bulk_till$uFastN<-bulk_till$uFastN+(froot_turnover_n[i]*pct_soil_tilled*root_litter_fastfrac*(1-rhizo_frac))
bulk_till$uSlowN<-bulk_till$uSlowN+(froot_turnover_n[i]*pct_soil_tilled*(1-root_litter_fastfrac)*(1-rhizo_frac))
bulk$uFastC<-bulk$uFastC+(froot_turnover_c[i]*(1-pct_soil_tilled)*root_litter_fastfrac*(1-rhizo_frac))
bulk$uSlowC<-bulk$uSlowC+(froot_turnover_c[i]*(1-pct_soil_tilled)*(1-root_litter_fastfrac)*(1-rhizo_frac))
bulk$uFastN<-bulk$uFastN+(froot_turnover_n[i]*(1-pct_soil_tilled)*root_litter_fastfrac*(1-rhizo_frac))
bulk$uSlowN<-bulk$uSlowN+(froot_turnover_n[i]*(1-pct_soil_tilled)*(1-root_litter_fastfrac)*(1-rhizo_frac))
##Transfer a portion of the litter layer to the bulk and rhizosphere each time step
newsoil<-litter*litter_transfer_to_soil
# Divide the newsoil into the till and non till layers according to the size of the till layer (pct_soil_tilled)
rhizo_till<-rhizo_till+(newsoil*pct_soil_tilled*rhizo_frac)
bulk_till<-bulk_till+(newsoil*pct_soil_tilled*(1-rhizo_frac))
rhizo<-rhizo+(newsoil*(1-pct_soil_tilled)*(rhizo_frac))
bulk<-bulk+(newsoil*(1-pct_soil_tilled)*(1-rhizo_frac))
litter<-litter-(litter*litter_transfer_to_soil)
##Add fungal production to bulk and rhizo layers
fungal_prod2<-fungal_prod[i,]
rhizo_till$uFastC<-rhizo_till$uFastC+(fungal_prod2*pct_soil_tilled*rhizo_frac)
rhizo$uFastC<-rhizo$uFastC+(fungal_prod2*(1-pct_soil_tilled)*rhizo_frac)
bulk_till$uFastC<-bulk_till$uFastC+(fungal_prod2*pct_soil_tilled*(1-rhizo_frac))
bulk$uFastC<-bulk$uFastC+(fungal_prod2*(1-pct_soil_tilled)*(1-rhizo_frac))
rhizo_till$uFastN<-rhizo_till$uFastN+(((fungal_prod2*pct_soil_tilled)/exudate_CN)*rhizo_frac)
rhizo$uFastN<-rhizo$uFastN+(((fungal_prod2*(1-pct_soil_tilled))/exudate_CN)*rhizo_frac)
bulk_till$uFastN<-bulk_till$uFastN+(((fungal_prod2*pct_soil_tilled)/exudate_CN)*(1-rhizo_frac))
bulk$uFastN<-bulk$uFastN+(((fungal_prod2*(1-pct_soil_tilled))/exudate_CN)*(1-rhizo_frac))
##Add in non mycorrhizal C flux to rhizosphere
rhizoC_flux2<-rhizoC_flux[i,]
rhizo_till$uFastC<-rhizo_till$uFastC+rhizoC_flux2*pct_soil_tilled
rhizo$uFastC<-rhizo$uFastC+rhizoC_flux2*(1-pct_soil_tilled)
# SJ 2/9/2021- no OMAD addition at UI Energy Farm
# ORGANIC MATTER ADDITION
# add to litter layer, lignin fraction to slow pool, everything else to fast pool
# can copy and paste same code from litter addition
# can be coded to pull input$omadlig value for 0.5 values
#
# if (input$omad[i] == 1){
#   litter$uFastC <- litter$uFastC + ((input$omadc[i] / 1000) * (1 - 0.5))
#   litter$uSlowC<-litter$uSlowC + ((input$omadc[i] / 1000) * 0.5)
#   litter$uFastN <- litter$uFastN + (((input$omadc[i] / 1000) * (1 - 0.5) / 40))
#   litter$uSlowN<-litter$uSlowN + (((input$omadc[i] / 1000) * 0.5) / 40)
# }
# TILLAGE - Moving tillage protectedC to unprotectedC
if (input$cult[i] == 1) {
soilMix_rhizo <- rhizo_till * input$cultrhizmix[i]
bulk_till <- bulk_till + soilMix_rhizo
rhizo_till <- rhizo_till - soilMix_rhizo
bulk_till <- bulk_till + (litter * input$cultlitmix[i])
litter <- litter * (1 - input$cultlitmix[i])
rhizo_till$uFastC<-rhizo_till$uFastC+(rhizo_till$pFastC*tillPtoUP)
rhizo_till$pFastC<-rhizo_till$pFastC-(rhizo_till$pFastC*tillPtoUP)
rhizo_till$uFastN<-rhizo_till$uFastN+(rhizo_till$pFastN*tillPtoUP)
rhizo_till$pFastN<-rhizo_till$pFastN-(rhizo_till$pFastN*tillPtoUP)
rhizo_till$uSlowC<-rhizo_till$uSlowC+(rhizo_till$pSlowC*tillPtoUP)
rhizo_till$pSlowC<-rhizo_till$pSlowC-(rhizo_till$pSlowC*tillPtoUP)
rhizo_till$uSlowN<-rhizo_till$uSlowN+(rhizo_till$pSlowN*tillPtoUP)
rhizo_till$pSlowN<-rhizo_till$pSlowN-(rhizo_till$pSlowN*tillPtoUP)
rhizo_till$uNecroC<-rhizo_till$uNecroC+(rhizo_till$pNecroC*tillPtoUP)
rhizo_till$pNecroC<-rhizo_till$pNecroC-(rhizo_till$pNecroC*tillPtoUP)
rhizo_till$uNecroN<-rhizo_till$uNecroN+(rhizo_till$pNecroN*tillPtoUP)
rhizo_till$pNecroN<-rhizo_till$pNecroN-(rhizo_till$pNecroN*tillPtoUP)
bulk_till$uFastC<-bulk_till$uFastC+(bulk_till$pFastC*tillPtoUP)
bulk_till$pFastC<-bulk_till$pFastC-(bulk_till$pFastC*tillPtoUP)
bulk_till$uFastN<-bulk_till$uFastN+(bulk_till$pFastN*tillPtoUP)
bulk_till$pFastN<-bulk_till$pFastN-(bulk_till$pFastN*tillPtoUP)
bulk_till$uSlowC<-bulk_till$uSlowC+(bulk_till$pSlowC*tillPtoUP)
bulk_till$pSlowC<-bulk_till$pSlowC-(bulk_till$pSlowC*tillPtoUP)
bulk_till$uSlowN<-bulk_till$uSlowN+(bulk_till$pSlowN*tillPtoUP)
bulk_till$pSlowN<-bulk_till$pSlowN-(bulk_till$pSlowN*tillPtoUP)
bulk_till$uNecroC<-bulk_till$uNecroC+(bulk_till$pNecroC*tillPtoUP)
bulk_till$pNecroC<-bulk_till$pNecroC-(bulk_till$pNecroC*tillPtoUP)
bulk_till$uNecroN<-bulk_till$uNecroN+(bulk_till$pNecroN*tillPtoUP)
bulk_till$pNecroN<-bulk_till$pNecroN-(bulk_till$pNecroN*tillPtoUP)
}
# FERTILIZER
#add n to shared inorganic n pool
if (input$fert[i] == 1){
shared_inorganicN <- shared_inorganicN + (input$fertamt[i] / 1000)
}
# Reassign CO2 values to each pool
bulk_till$CO2<-CO2_bulk_till
bulk$CO2<-CO2_bulk
rhizo_till$CO2<-CO2_rhizo_till
rhizo$CO2<-CO2_rhizo
litter$CO2<-CO2_litter
## Fill in the second column of each datatable with values from the first- because code is designed to run with at least 2 sites
bulk_till[2,] <- bulk_till[1,]
bulk[2,] <- bulk[1,]
rhizo_till[2,] <- rhizo_till[1,]
rhizo[2,] <- rhizo[1,]
litter[2,] <- litter[1,]
##END of CORPSE main loop
##Update FUN model shared_inorganic N with CORPSE model shared_inorganic N
##FUN_shared_inorganicN[i, j] <-shared_inorganicN[1]
for (j in 1:nsites) {
FUN_shared_inorganicN[i, j] <-shared_inorganicN[1]
##Start of FUN model main loop
##Assume passive uptake with transpiration is zero
Npassive[i,j]<-0
Npassive[i,j]<-pmin(Npassive[i,j],FUN_shared_inorganicN[i,j])
##Calculate soil N remaining- update N pool after any passive uptake
rsoilN[i,j]<-FUN_shared_inorganicN[i,j]-Npassive[i,j]
##Sum passive and storage N allocation
free[i,j]<-Npassive[i,j]
##Calculate the cost for each uptake strategy
##N fixation costs
cost_fix[i,j]<-(s_fix*exp(a_fix+b_fix*soilT[k]*(1-0.5*soilT[k]/c_fix))-2*s_fix)
##Make the cost of retranslocation high during green season
cost_resorb[i,j]<-Inf
##Update FUN model shared_inorganic N with remaining soil N calculated
FUN_shared_inorganicN[i,j]<-rsoilN[i,j]
##cost of non mycorrhizal uptake - +inf
cost_non_myco[i,j]<-(Non_kN/FUN_shared_inorganicN[i,j])+(Non_kC/daily_root_bio_juv[i,j])
##cost of mycorrhizal uptake - +inf
cost_active[i,j]<-(kN/FUN_shared_inorganicN[i,j])+(kC/daily_root_bio_juv[i,j])
##Making cost of N storage high after growing season
leafNdaystorage <- 365
if(leafN[i,1] == 1){ # if it is a last day
leafNdaystorage <- input$doy[i] # then assign leafNdaystorage to that last day DOY
}
if(input$doy[i] > leafNdaystorage){ # make cost of storage infinite after last day
cost_storage[i,j]<-Inf
}
if(input$doy[i] > 364){ # this resets the leafNdaystorage for each year
leafNdaystorage <- input$doy[i]
}
##Making cost of N storage high if storage N is equal to 0
if (FUNstorageN[i,j]<=0) {
cost_storage[i,j]<-Inf
}
##Adding in a newer retranslocation function that calculates at an annual scale
##and it spreads over the senescence period
##Calculate cost of resorption
##leafN is a df w/ same # rows as input & columns 1:4 =
## 1) input$last (0,1),
## 2) input$harv (0,1),
## 3) input$aglivn (continuous), and
## 4) retranslocatable leaf N pool (continuous)
leafNday <- 365
leafN2 <- 0 # initialize a new value
if (leafN[i,1] == 1) { # if a last day...
cost_resorb[i,j]<-kR/leafN[i,4] # calculate resorb cost
leafN2 <- leafN[i,4] # set leafN2 = retranslocatable leaf N pool
leafNday <- input$doy[i] # set leafNday = doy
} # Else leafN2 <- 0
##use resistance network to get integrated cost
rec_cost_acq[i,j]<-(
(1/cost_active[i,j])
+(1/cost_fix[i,j])
+(1/cost_resorb[i,j])
+(1/cost_non_myco[i,j])
+(1/cost_storage[i,j])
)
cost_acq[i,j]<-(1/rec_cost_acq[i,j])
##This code below simultaneously solves eqs. 6a-6d from Fisher et al. 2010
##to optimize C allocated to growth and N uptake. N uptake is truncated if
##Ndemand is met or leaf N pool is exhausted.
##Add in storage N demand to pool
if (leafN[i,1] == 1) { # if it is a last day...
Ndemand_plus_storage[i,j]<-totalNdemand[i-1,j]+storageNdemand[i]
##Add in storage C into NPP or C available pool
NPP_plus_storage[i,j]<-NPP[i-1,j]+storageC[i]
} else {
NPP_plus_storage[i,j]<-NPP[i,j]
Ndemand_plus_storage[i,j]<-totalNdemand[i,j]
}
Cavailable[i,j]<-NPP_plus_storage[i,j]
Ndeficit[i,j]<-Ndemand_plus_storage[i,j]
if (Ndeficit[i,j]<=0) {
Nacq[i,j]<-0
Cacq[i,j]<-0
Cgrowth[i,j]<-Cgrowth[i,j]
}
if (Ndeficit[i,j]>0) {
Cacq[i,j]<-(Cavailable[i,j]-(free[i,j]*(plantCN[i,j])))/
(1+(plantCN[i,j])/cost_acq[i,j])
Nacq[i,j]<-pmin(Ndeficit[i,j],(Cacq[i,j]/cost_acq[i,j]))
Cgrowth[i,j]<-Cavailable[i,j]-(Nacq[i,j]*cost_acq[i,j])
total_Nacq_active[i,j]<-Cacq[i,j]/cost_active[i,j]
total_Nacq_non_myco[i,j]<-Cacq[i,j]/cost_non_myco[i,j]
total_Nacq_resorb[i,j]<-Cacq[i,j]/cost_resorb[i,j]
total_Nacq_fix[i,j]<-Cacq[i,j]/cost_fix[i,j]
total_Nacq_storage[i,j]<-Cacq[i,j]/cost_storage[i,j]
}
total_Nacq_storage[i]<-pmin(total_Nacq_storage[i,j],FUNstorageN[i,j])
total_Nacq[i,j]<-(
total_Nacq_active[i,j]
+total_Nacq_fix[i,j]
+total_Nacq_non_myco[i,j]
+total_Nacq_resorb[i,j]
+total_Nacq_storage[i,j]
)
if (total_Nacq[i,j]>Ndeficit[i,j]){
Nacq_scaler<-Ndeficit[i,j]/total_Nacq[i,j]
total_Nacq_active[i,j]<-total_Nacq_active[i,j]*Nacq_scaler
total_Nacq_fix[i,j]<-total_Nacq_fix[i,j]*Nacq_scaler
total_Nacq_non_myco[i,j]<-total_Nacq_non_myco[i,j]*Nacq_scaler
total_Nacq_resorb[i,j]<-total_Nacq_resorb[i,j]*Nacq_scaler
total_Nacq_storage[i,j]<-total_Nacq_storage[i,j]*Nacq_scaler
}
##Truncate resorb if exceeds leaf N
if (total_Nacq_resorb[i,j]>leafN2) { # should be day before harvest
total_Nacq_resorb[i,j]<-leafN2
Cgrowth[i,j]<-Cavailable[i,j]-(Nacq[i,j]*cost_acq[i,j])
}
##Update Storage N pool to include retranslocation
if (leafN[i,1] == 0) { #  if not a last day...
FUNstorageN[i+1,j]<-FUNstorageN[i,j]-total_Nacq_storage[i,j]
}
if(FUNstorageN[i+1,j] < 0){
FUNstorageN[i+1,j] <- 0
}
if (leafN[i,1] == 1) { # if a last day...
total_Nacq_active[i,j]<-0
total_Nacq_fix[i,j]<-0
total_Nacq_non_myco[i,j]<-0
FUNstorageN[i+1,j]<-(
FUNstorageN[i,j]
+total_Nacq_resorb[i,j]
+total_Nacq_active[i,j]
+total_Nacq_non_myco[i,j]
+total_Nacq_fix[i,j]
)
}
if (input$doy[i] > leafNday) { # harvest date #
FUNstorageN[i+1,j]<-FUNstorageN[i,j]-total_Nacq_storage[i,j]
}
if (leafN[i,1] == 1){
resorbper[j]<-(1-(total_Nacq_resorb[i,j]/leafN2))
litter_productionN[i,j]<-(leafN[i,j]*resorbper[j])
litter_productionCN[i,j]<-litter_production_c[i]/litter_production_n[i]
}
total_soil_N_uptake[i,j]<-total_Nacq_active[i,j]+total_Nacq_non_myco[i,j]
##Scale FUN inorganic N based on N uptake calculated by FUN
if(total_soil_N_uptake[i,j]>FUN_shared_inorganicN[i,j]) {
N_uptakescaler[i,j]<-FUN_shared_inorganicN[i,j]/total_soil_N_uptake[i,j]
total_Nacq_active[i,j]<- total_Nacq_active[i,j]*N_uptakescaler[i,j]
total_Nacq_non_myco[i,j]<-total_Nacq_non_myco[i,j]*N_uptakescaler[i,j]
total_soil_N_uptake[i,j]<-FUN_shared_inorganicN[i,j]
} else {
N_uptakescaler[i,j]<-0
}
total_Nacq[i,j]<-(
total_Nacq_active[i,j]
+total_Nacq_fix[i,j]
+total_Nacq_non_myco[i,j]
+total_Nacq_resorb[i,j]
+total_Nacq_storage[i,j]
)
}
##Update Corpse model shared_inorganic N pool with FUN inorganic N pool
shared_inorganicN<-FUN_shared_inorganicN[i,]-total_soil_N_uptake[i,]
##Calculate fungal production and rhizosphere C flux to be input into CORPSE model
if(i<timestep){
fungal_prod[i+1,]<- total_Nacq_active[i,]*cost_acq[i,]
rhizoC_flux[i+1,]<- total_Nacq_non_myco[i,]*cost_acq[i,]
}
##end of FUN model main loop
}
